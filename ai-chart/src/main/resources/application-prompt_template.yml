ai:
  prompt:
    templates:
      select_table:
        system: |
          You are an expert in database schema understanding.
        user: |
          Your task is identify which tables are relevant to the query (fact and dimension tables) based on the given information.
          
          ### Inputs:
          User query: ${user_query}
          Candidate table descriptions:
          <#list table_descriptions as item>
            - ${item}
          </#list>
          
          ### Output Format:
          Return ONLY a JSON object matching one of the schemas below. No extra text.
          Success:
          {
            "success": true,
            "tables": [
              {
                "table_id": "exact_table_id_from_input",
                "table_name": "exact_table_name_from_input",
                "description": "exact_description_from_input",
                "additional_info": "exact_additional_info_from_input"
              }
            ]
          }
          
          Failure:
          {
            "success": false,
            "error": "<language-specific reason>"
          }
          
          **Strict Constraints:**
          - Use the exact table names, descriptions, and additional_info as provided in the input.
          - Do not modify, transform, or reformat any of the provided information.
          - Preserve the exact case, spacing, and formatting of all input data.
          - Do not wrap the response in Markdown code blocks.
          - Do not include any reasoning or thinking process in your response.
      generate_sql:
        system: |
          You are an expert in generating SQL queries from natural language, specifically for ${sql_syntax} syntax.
        user: |
          Your task is to generate an accurate SQL query based on the given information.

          ### Inputs:
          Current date:
          ${current_date}
            Date Format Specification:
            When the user question does not explicitly specify a date format, use the following standard format for date columns:
            - **YYYY-MM-DD** format for date literals
            - **YYYY-MM-DD HH:MM:SS** format for datetime literals
          User's Question:
          ${user_query}
          Relevant Tables:
          <#list relevant_tables as table>
          - **Table**: ${table.table_name}
            - **Description**: ${table.description}
            - **Additional Info**: ${table.additional_info}
            - **Columns**:
            <#list table.fields as item>
              - ${item}
            </#list>
          </#list>

          ### Reasoning Process:
          1. **Identify the relevant tables**: Determine which tables are needed based on the user question.
          2. **Extract required fields**: Identify the columns that should be included in the query.
          3. **Construct the SQL query**: Assemble the final query using the extracted information, ensuring it follows SQL syntax and best practices.
          4. **Check for user-specified limits**: Look for explicit row limit requests in the user question.
          5. **Apply default limit**: If no user limit is specified, add LIMIT 100 as the final clause.
          6. **Avoid assumptions**: Do not assume any table join relationships that are not explicitly provided in the information.
          7. **Finalize the SQL query**: Provide a well-structured and clear SQL query that answers the user's question accurately.
          8. **Chart-friendly output**: Ensure the SELECT list contains both dimension columns (e.g., date, category) and metric columns (e.g., count, sum, avg) with clear aliases so the result can be directly used for ECharts.
          9. **Reject non-query requests**: If the user asks for INSERT, UPDATE, DELETE, DROP, ALTER, CREATE, or any non-SELECT operation, immediately return: { "success":false,"error":"Only SELECT queries are allowed" }

          ### Output Format:
          Return ONLY a JSON object matching one of the schemas below. No extra text.
          Success schema:
          {
            "success": true,
            "sql": "<generated SQL>",
            "columns": [
              {
                "column_name": "<column name>",
                "display_name": "<language-specific display name>"
              }
            ]
          }
          
          Failure schema (If the request is not a SELECT or cannot be fulfilled):
          {
            "success": false,
            "error": "<language-specific reason>"
          }
          
          **Strict Constraints:**
          - Use only the provided tables, columns, and code table values.
          - Do not use any table, column, or value not explicitly listed.
          - Do not wrap the response in Markdown code blocks.
          - Do not include any reasoning or thinking process in your response.
      generate_chart:
        system: |
          You are an expert in data visualization.
        user: |
          Your task is to return **JSON metadata** for ECharts or table rendering based on the user question, SQL and query result.
          Do NOT include real data or full ECharts option.
          
          ### Inputs
          User Question: ${user_query}
          Executed SQL: ${sql}
          Query Result: ${query_result}
          
          ### Steps
          1. List every column and its meaning.
          2. Decide displayType: "chart" or "table".
          3. Map columns:
             - chart: dimension, metric, series, color, tooltip, sort.
             - table: column title, width, align, formatter, sort.
          4. Provide optional chart options: type, stack, smooth, legend, grid, toolbox, axisName, unit, decimals.
          5. Provide meta: title, subtitle.
          
          ### Output Format
          Return ONLY a JSON object matching one of the schemas below. No extra text.
          Success:
          {
            "success": true,
            "config": {
              "displayType": "chart" | "table",
              "chartType?": "bar" | "line" | "pie" | "scatter" | "funnel" | "radar" | "gauge",
              "fieldMapping": {
                // chart
                "xAxis?": "<col>",
                "yAxis?": "<col>",
                "series?": "<col>",
                "color?": "<col>",
                "tooltip?": "<col>",
                // table
                "columns?": [
                  {
                    "key": "<col>",
                    "title": "<language-specific display name>"
                  }
                ]
              },
              "options": {
                "smooth?": true | false,
                "legend?": true | false,
                "axisName?": { "x": "<language-specific xAxisName>", "y": "<language-specific yAxisName>" },
              },
              "meta": {
                "title": "<title>",
                "description?": "<description>"
              }
            }
          }
          
          Failure:
          { "success": false, "error": "<language-specific reason>" }
          
          **Strict Constraints:**
          - Use only actual column names.
          - No Markdown code blocks.
          - Do not include any reasoning or thinking process in your response.
      fix_sql:
        system: |
          You are an SQL expert, specifically for ${sql_syntax} syntax. Fix the given SQL according to the error message and provided table schema.
        user: |          
          SQL:
          ${sql}
          
          Error:
          ${error}
          
          Date Format Specification:
          When the original SQL does not explicitly specify a date format, use the following standard format for date columns:
          - **YYYY-MM-DD** format for date literals
          - **YYYY-MM-DD HH:MM:SS** format for datetime literals
          - Use CAST or TO_DATE functions when necessary to ensure consistent date handling

          Relevant Tables:
          <#list relevant_tables as table>
          - **Table**: ${table.table_name}
            - **Description**: ${table.description}
            - **Additional Info**: ${table.additional_info}
            - **Columns**:
            <#list table.fields as item>
              - ${item}
            </#list>
          </#list>

          Task:
          1. Analyze the error and schema.
          2. Return ONLY a JSON object matching one of the schemas below.
          Success schema:
          {
            "success": true,
            "sql": "<fixed SQL>"
          }
          
          Failure schema:
          {
            "success": false,
            "error": "<language-specific reason>"
          }
          
          **Strict Constraints:**
          - Use only the provided tables, columns, and code table values.
          - Do not use any table, column, or value not explicitly listed.
          - Do not wrap the response in Markdown code blocks.
          - Do not include any reasoning or thinking process in your response.
      analyze_data:
        system: |
          You are a data analysis expert skilled at identifying patterns, trends, and insights from structured data.
        user: |
          Your task is to perform data analysis on the provided query result based on the user question.
          
          ### Inputs
          User Question: ${user_query}
          Query Result: ${query_result}
          Column Aliases: ${column_aliases}
          
          ### Analysis Requirements
          1. Identify key trends, patterns, or anomalies in the data
          2. Calculate relevant statistics (sum, average, min, max, etc.) where applicable
          3. Highlight any significant findings or insights
          4. Provide a concise summary of the data characteristics
          5. When analyzing data, consider that column names in the query result may be aliases for physical fields. Use the provided column aliases mapping to understand the relationship between alias names and physical column names.
          
          ### Output Format
          Return ONLY a JSON object containing the analysis results:
          Success:
          {
            "success": true,
            "insights": [
              "<key_insight_1>",
              "<key_insight_2>",
              "<...>",
              "<key_insight_n>"
            ]
          }
          
          Failure:
          {
            "success": false,
            "error": "<language-specific reason>"
          }
          
          **Strict Constraints:**
          - Return only the analysis results without any additional information
          - Do not include any visualizations or charts
          - Do not wrap the response in Markdown code blocks
          - Do not include any reasoning or thinking process in your response
      generate_report:
        system: |
          You are a professional data analyst and technical writer skilled at creating comprehensive, visually appealing, and insightful data reports.
        user: |
          Your task is to create a comprehensive HTML report based on the data analysis results and user requirements.
          
          ### Inputs
          User Question: ${user_query}
          Query Result: ${query_result}
          Data Analysis Results:
          <#list analysis_results as item>
             - ${item}
          </#list>
          Column Aliases: ${column_aliases}
          Current Time: ${current_time}
          
          ### Report Requirements
          1. **Content Structure**:
             - Executive Summary
             - Data Analysis Process
             - Detailed Analysis Results
             - Business Insights
             - Recommendations and Action Plan
             - Generated Time Footer (format: YYYY-MM-DD HH:MM:SS)
          
          2. **Design Requirements**:
             - Implement light mode only, without dark mode toggle
             - Apply glass morphism effects (backdrop-filter, blur, sophisticated shadows)
             - Use modern gradient colors and color hierarchy
             - Add micro-interactions (card hover effects, smooth transitions)
             - Responsive grid layout system
             - Modern card design with rounded corners and shadows
             - 3D effect interactive elements
             - Loading animations for data visualization components
          
          3. **Technical Specifications**:
             - Use CSS variables for color system definition
             - Apply modern CSS features (clamp(), aspect-ratio, gap)
             - Add transition effects to all interactive elements
             - Remove all buttons and interactive elements that require JavaScript
          
          4. **Content Requirements**:
             - All data and conclusions must be based on provided information
             - Include all important content information from the analysis
             - Maintain logical connections between report sections
             - Create static elements for data exploration
             - Use CDN for required resources (Tailwind CSS, ECharts)
             - Embed all styles directly in the HTML file
             - Ensure HTML code meets W3C standards
          
          ### Output Format
          Return ONLY a JSON object containing the analysis results:
          Success:
          {
            "success": true,
            "html": "<html page>"
          }
          
          Failure:
          {
            "success": false,
            "error": "<language-specific reason>"
          }
          
          **Strict Constraints**:
          - Return only the generated HTML report without any additional information
          - Do not wrap the response in Markdown code blocks
          - Do not include any reasoning or thinking process in your response
          - Ensure all data visualizations are clear and properly labeled
          - Do not include empty DOM nodes
          - Do not fabricate or hallucinate any data